<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Demo: Piedras (Top‑Down) – HTML/JS single file</title>
  <style>
    :root{
      --bg: #0f172a; /* slate-900 */
      --panel: #111827; /* gray-900 */
      --accent: #38bdf8; /* sky-400 */
      --text: #e5e7eb; /* gray-200 */
      --muted: #94a3b8; /* slate-400 */
      --danger: #ef4444; /* red-500 */
      --ok: #22c55e; /* green-500 */
      --enemy: #f59e0b; /* amber-500 */
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"}
    .wrap{display:grid;place-items:center;min-height:100%;padding:16px;gap:16px}
    canvas{background:#0b1220;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .hud{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:center}
    .pill{background:var(--panel);border:1px solid rgba(255,255,255,.06);padding:8px 12px;border-radius:999px;color:var(--muted);font-size:14px}
    .title{font-weight:700;color:#fff}
    .accent{color:var(--accent)}
    .kbd{background:#161e31;border:1px solid #233154;padding:2px 6px;border-radius:6px;color:#cbd5e1;font-weight:600}
    .footer{color:var(--muted);font-size:12px}
    a{color:var(--accent);text-decoration:none}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <span class="pill title">Demo <span class="accent">Piedras</span> — HTML + CSS + JS</span>
      <span class="pill">Mover: <span class="kbd">Click Izq</span></span>
      <span class="pill">Levantar roca: acercate y <span class="kbd">Click Izq</span> sobre la roca</span>
      <span class="pill">Lanzar: <span class="kbd">Click Der</span> o <span class="kbd">Espacio</span></span>
      <span class="pill">Inventario máx.: 3</span>
      <span class="pill">Niveles con oleadas y jefe (L5)</span>
    </div>

    <canvas id="game" width="960" height="540" aria-label="Juego top‑down de lanzar piedras"></canvas>

    <div class="footer">Oleadas por nivel: L1=2 enemigos, L2=4, L3=8, L4=16; L5=Jefe gigante (4×) con <strong>400 HP</strong>, hace <strong>el doble de daño</strong> al contacto y <strong>borra las piedras</strong> que pisa. Al completar L5, vuelve a L1 y los enemigos hacen el doble de daño (se acumula por ciclo). HP jugador 100, 3 vidas; matar enemigo cura +5. R = reiniciar en Game Over.</div>
  </div>

<script>
(() => {
  // High‑DPI canvas setup
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = window.devicePixelRatio || 1;
  function resizeCanvas() {
    const cssW = canvas.width, cssH = canvas.height; // fixed CSS size
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * DPR);
    canvas.height = Math.round(cssH * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0); // draw in CSS pixels
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // Basic Vec helpers
  const V = (x=0,y=0)=>({x,y});
  const len = v => Math.hypot(v.x, v.y);
  const add = (a,b)=>V(a.x+b.x, a.y+b.y);
  const sub = (a,b)=>V(a.x-b.x, a.y-b.y);
  const mul = (v,k)=>V(v.x*k, v.y*k);
  const norm = v => { const L = len(v); return L>1e-6 ? V(v.x/L, v.y/L) : V(0,0); };

  // RNG
  const rng = (seed => () => (seed = (seed*1664525 + 1013904223)>>>0) / 2**32)(42);
  const rand = (a,b)=> a + (b-a)*rng();

  // World settings
  const W = canvas.width / DPR, H = canvas.height / DPR;
  const rockSizes = [6, 10, 16];
  const rockWeights = [5, 3, 2];
  const initialRocks = 70;

  // Entities
  const rocks = [];
  const projectiles = [];
  const enemies = [];
  let score = 0;
  let gameOver = false;

  // Waves/Levels
  let level = 1;        // 1..5 (5 = boss)
  let cycle = 0;        // how many times we've finished L5
  let enemiesToSpawn = 0;
  let spawnTimer = 0;
  let spawnInterval = 2.8; // base spawn cadence within a level
  let levelBannerTimer = 2.0; // seconds to show level banner

  const damageMultiplier = () => Math.pow(2, cycle); // doubles each cycle

  const player = {
    pos: V(W/2, H/2),
    radius: 14,
    speed: 160, // px/s
    target: V(W/2, H/2),
    hasTarget: false,
    inventory: [],
    capacity: 3,
    maxHp: 100,
    hp: 100,
    lives: 3,
    iTimer: 0, // invulnerable timer after hit
    lastHitAt: 0,
  };

  // Rocks: initial scatter + periodic spawns
  for (let i=0;i<initialRocks;i++) spawnRock();
  let rockSpawnTimer = 0;
  const rockSpawnInterval = 4.0; // nueva roca cada 4s

  function spawnRock(){
    const rIndex = weightedPick(rockWeights);
    const radius = rockSizes[rIndex];
    rocks.push({ pos: V(rand(40, W-40), rand(40, H-40)), radius, picked:false });
  }

  function weightedPick(weights){
    const s = weights.reduce((a,b)=>a+b,0);
    let t = rand(0,s);
    for (let i=0;i<weights.length;i++){
      if ((t -= weights[i]) <= 0) return i;
    }
    return weights.length-1;
  }

  // Levels config
  function startLevel(n){
    level = n;
    spawnTimer = 0;
    levelBannerTimer = 2.0;
    if (level >= 1 && level <= 4){
      enemiesToSpawn = Math.pow(2, level); // L1=2, L2=4, L3=8, L4=16
    } else if (level === 5){
      enemiesToSpawn = 1; // Boss
    }
  }

  startLevel(1);

  // Input handling
  const mouse = { x:0, y:0 };
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left);
    mouse.y = (e.clientY - rect.top);
  });

  canvas.addEventListener('contextmenu', e => e.preventDefault());

  canvas.addEventListener('mousedown', e => {
    if (gameOver) return;
    const btn = e.button; // 0 L, 2 R
    if (btn === 0){ // Left click: pick or move
      let pickedAny = false;
      for (const r of rocks){
        if (r.picked) continue;
        const dClick = Math.hypot(mouse.x - r.pos.x, mouse.y - r.pos.y);
        if (dClick <= r.radius + 6){
          if (near(player, r)){
            if (player.inventory.length < player.capacity){
              r.picked = true;
              player.inventory.push({ radius: r.radius });
              pickedAny = true;
              break;
            }
          }
        }
      }
      if (!pickedAny){
        player.target = V(mouse.x, mouse.y);
        player.hasTarget = true;
      }
    }
    if (btn === 2){ // Right click: throw
      throwRockToward(mouse);
    }
  });

  window.addEventListener('keydown', e => {
    if (e.code === 'Space'){
      e.preventDefault();
      throwRockToward(mouse);
    }
    if (e.code === 'KeyR'){
      if (gameOver) resetGame();
    }
  }, {passive:false});

  function near(pl, rock, margin=4){
    return Math.hypot(pl.pos.x - rock.pos.x, pl.pos.y - rock.pos.y) <= (pl.radius + rock.radius + margin);
  }

  function throwRockToward(target){
    if (gameOver) return;
    if (player.inventory.length === 0) return;
    // take largest radius
    let idx = 0;
    for (let i=1;i<player.inventory.length;i++){
      if (player.inventory[i].radius > player.inventory[idx].radius) idx = i;
    }
    const r = player.inventory.splice(idx,1)[0];
    const dir = norm(sub(target, player.pos));
    const mass = r.radius*r.radius; // area ~ mass
    const base = 420;
    const speed = base / Math.sqrt(Math.max(1, mass*0.02));
    const spawn = add(player.pos, mul(dir, player.radius + r.radius + 2));
    projectiles.push({ pos: spawn, vel: mul(dir, speed), radius: r.radius, alive: true });
  }

  // Spawning enemies per level
  function spawnEnemy(){
    if (level === 5){
      // Boss: 4x the largest normal enemy (largest radius = 20 -> 80)
      const radius = 80;
      const x = rand(80, W-80);
      const y = -radius - 20;
      const maxHp = 400; // jefe con 4× vida
      const speed = 30;  // slow giant
      enemies.push({ pos: V(x,y), radius, speed, hp: maxHp, maxHp, alive: true, boss: true });
      return;
    }
    // Normal enemies L1..L4
    const radius = rand(12, 20);
    const x = rand(30, W-30);
    const y = -radius - 14; // from top
    const maxHp = Math.round(radius * 4); // HP scales with size
    // Big -> slower mapping 12..20 -> 85..45 px/s
    const t = (radius - 12) / (20 - 12);
    const speed = 85 + (45 - 85) * Math.min(Math.max(t, 0), 1); // lerp descendente
    enemies.push({ pos: V(x,y), radius, speed, hp: maxHp, maxHp, alive: true, boss: false });
  }

  // Game loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    update(dt, now/1000);
    draw(now/1000);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(dt, t){
    if (!gameOver){
      // Player movement
      if (player.hasTarget){
        const dir = sub(player.target, player.pos);
        const d = len(dir);
        if (d < 2){
          player.hasTarget = false;
        } else {
          let step = mul(norm(dir), player.speed * dt);
          if (len(step) > d) step = dir;
          player.pos = add(player.pos, step);
        }
      }

      // Spawn within level
      if (enemiesToSpawn > 0){
        spawnTimer += dt;
        if (spawnTimer >= spawnInterval){
          spawnTimer = 0;
          spawnEnemy();
          enemiesToSpawn--;
          // small jitter
          spawnInterval = 2.4 + rand(-0.4, 1.2);
        }
      }

      // Enemies update (chase player)
      for (const e of enemies){
        const dir = norm(sub(player.pos, e.pos));
        e.pos = add(e.pos, mul(dir, e.speed * dt));
        // Jefe: borra piedras al pasar por encima
        if (e.boss){
          for (let i = rocks.length - 1; i >= 0; i--){
            const r = rocks[i];
            if (r.picked) continue;
            const d = Math.hypot(e.pos.x - r.pos.x, e.pos.y - r.pos.y);
            if (d <= e.radius + r.radius){
              rocks.splice(i,1);
            }
          }
        }
      }

      // Projectiles
      for (const p of projectiles){
        p.pos = add(p.pos, mul(p.vel, dt));
        if (p.pos.x < -50 || p.pos.x > W+50 || p.pos.y < -50 || p.pos.y > H+50) p.alive = false;
      }

      // Collisions: projectile vs enemy
      for (const e of enemies){
        if (!e.alive) continue;
        for (const p of projectiles){
          if (!p.alive) continue;
          const d = Math.hypot(e.pos.x - p.pos.x, e.pos.y - p.pos.y);
          if (d <= e.radius + p.radius){
            const damage = Math.round(p.radius * 3);
            e.hp -= damage;
            p.alive = false; // one‑hit projectile
            if (e.hp <= 0){
              e.alive = false; score += (e.boss ? 5 : 1);
              // heal player by 5 (cap at max)
              player.hp = Math.min(player.maxHp, player.hp + 5);
            }
          }
        }
      }

      // Collision: enemy touches player -> damage player (10 base, big = x2), times cycle multiplier
      const canBeHit = (t - player.lastHitAt) > 0.7; // 0.7s between hits
      for (const e of enemies){
        if (!e.alive) continue;
        const d = Math.hypot(e.pos.x - player.pos.x, e.pos.y - player.pos.y);
        if (d <= e.radius + player.radius){
          if (canBeHit){
            const isBig = e.boss || e.radius >= 18; // boss/large -> double base
            const base = e.boss ? 40 : (isBig ? 20 : 10);
            const dmg = base * damageMultiplier();
            player.hp -= dmg;
            player.lastHitAt = t;
            player.iTimer = 0.6; // brief invulnerability flicker
            // knockback
            const dir = norm(sub(player.pos, e.pos));
            player.pos = add(player.pos, mul(dir, 12));
            if (player.hp <= 0){
              player.lives -= 1;
              if (player.lives > 0){
                player.hp = player.maxHp;
                player.pos = V(W/2, H/2);
                player.hasTarget = false;
                player.iTimer = 1.2;
                // push away nearby enemies
                for (const en of enemies){
                  if (Math.hypot(en.pos.x - player.pos.x, en.pos.y - player.pos.y) < 80){
                    en.pos.y -= 120;
                  }
                }
              } else {
                gameOver = true;
              }
            }
          }
        }
      }

      // Nueva roca cada 4s
      rockSpawnTimer += dt;
      if (rockSpawnTimer >= rockSpawnInterval){
        rockSpawnTimer = 0;
        spawnRock();
      }

      // Cleanup dead/out
      for (let i=projectiles.length-1;i>=0;i--) if (!projectiles[i].alive) projectiles.splice(i,1);
      for (let i=enemies.length-1;i>=0;i--) if (!enemies[i].alive || enemies[i].pos.y > H + 120) enemies.splice(i,1);

      // timers
      if (player.iTimer > 0) player.iTimer = Math.max(0, player.iTimer - dt);

      // Check level complete: no enemies alive and none left to spawn
      if (!gameOver && enemiesToSpawn === 0 && enemies.length === 0){
        // advance level or cycle
        if (level < 5){
          startLevel(level + 1);
        } else {
          // finished boss level -> new cycle, damage doubles
          cycle += 1;
          startLevel(1);
        }
      }
    }
  }

  // Rendering
  function draw(t){
    // Background
    ctx.clearRect(0,0,W,H);
    drawGrid();

    // Rocks (floor)
    for (const r of rocks){
      if (!r.picked) drawRock(r);
    }

    // Projectiles
    for (const p of projectiles){
      drawProjectile(p);
    }

    // Enemies
    for (const e of enemies){
      drawEnemy(e);
    }

    // Player
    drawPlayer(player);

    // HUD
    drawInventory();
    drawScore();
    drawPlayerHP();
    drawLives();
    drawLevelBanner();

    if (gameOver) drawGameOver();
  }

  function drawGrid(){
    ctx.save();
    ctx.fillStyle = '#0b1220';
    ctx.fillRect(0,0,W,H);
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    const step = 40;
    ctx.beginPath();
    for (let x=0;x<=W;x+=step){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for (let y=0;y<=H;y+=step){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke();
    ctx.restore();
  }

  function drawRock(r){
    ctx.save();
    ctx.beginPath();
    ctx.arc(r.pos.x, r.pos.y, r.radius, 0, Math.PI*2);
    ctx.fillStyle = '#8b8f97';
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(0,0,0,0.8)';
    ctx.stroke();
    const g = ctx.createRadialGradient(r.pos.x-r.radius*0.4, r.pos.y-r.radius*0.4, r.radius*0.1, r.pos.x, r.pos.y, r.radius);
    g.addColorStop(0, 'rgba(255,255,255,0.25)');
    g.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = g;
    ctx.fill();
    ctx.restore();
  }

  function drawProjectile(p){
    ctx.save();
    ctx.beginPath();
    ctx.arc(p.pos.x, p.pos.y, p.radius, 0, Math.PI*2);
    ctx.fillStyle = '#6b7280';
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(0,0,0,0.85)';
    ctx.stroke();
    ctx.restore();
  }

  function drawEnemy(e){
    ctx.save();
    ctx.beginPath();
    ctx.arc(e.pos.x, e.pos.y, e.radius, 0, Math.PI*2);
    ctx.fillStyle = '#f59e0b';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.9)';
    ctx.stroke();

    // health bar
    const barW = Math.max(24, e.radius*2);
    const barH = 5;
    const x = e.pos.x - barW/2;
    const y = e.pos.y - e.radius - 10;
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    roundRect(ctx, x-1, y-1, barW+2, barH+2, 3);
    ctx.fill();
    ctx.fillStyle = '#7f1d1d';
    roundRect(ctx, x, y, barW, barH, 3);
    ctx.fill();
    const ratio = Math.max(0, e.hp / e.maxHp);
    ctx.fillStyle = '#22c55e';
    roundRect(ctx, x, y, barW*ratio, barH, 3);
    ctx.fill();
    ctx.restore();
  }

  function drawPlayer(pl){
    ctx.save();
    // flicker when invulnerable
    if (pl.iTimer > 0){
      if (Math.floor(performance.now()/100)%2===0){ ctx.globalAlpha = 0.5; }
    }
    // Shadow
    ctx.beginPath();
    ctx.arc(pl.pos.x+2, pl.pos.y+3, pl.radius, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fill();

    // Body
    const grad = ctx.createRadialGradient(pl.pos.x-pl.radius*0.4, pl.pos.y-pl.radius*0.4, 4, pl.pos.x, pl.pos.y, pl.radius);
    grad.addColorStop(0, '#8bd4ff');
    grad.addColorStop(1, '#38bdf8');
    ctx.beginPath();
    ctx.arc(pl.pos.x, pl.pos.y, pl.radius, 0, Math.PI*2);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.9)';
    ctx.stroke();

    // Target indicator
    if (player.hasTarget){
      ctx.setLineDash([6,6]);
      ctx.lineDashOffset = (performance.now()/100) % 12;
      ctx.beginPath();
      ctx.moveTo(pl.pos.x, pl.pos.y);
      ctx.lineTo(player.target.x, player.target.y);
      ctx.strokeStyle = 'rgba(56,189,248,0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(player.target.x, player.target.y, 8, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawInventory(){
    const x0 = 12, y0 = 12;
    ctx.save();
    ctx.fillStyle = 'rgba(17,24,39,0.9)';
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    roundRect(ctx, x0-6, y0-6, 170, 50, 10);
    ctx.fill(); ctx.stroke();

    let x = x0;
    for (let i=0;i<player.capacity;i++){
      const r = player.inventory[i]?.radius ?? 0;
      if (r){
        ctx.beginPath();
        ctx.arc(x + r, y0 + r, r, 0, Math.PI*2);
        ctx.fillStyle = '#9ca3af';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.85)';
        ctx.stroke();
        x += r*2 + 6;
      } else {
        const er = 10;
        ctx.beginPath();
        ctx.arc(x + er, y0 + er, er, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.stroke();
        x += er*2 + 6;
      }
    }

    ctx.fillStyle = 'rgba(226,232,240,0.75)';
    ctx.font = '12px system-ui, sans-serif';
    ctx.fillText('Inventario', x0, y0 + 38);
    ctx.restore();
  }

  function drawScore(){
    const text = `Puntaje: ${score}`;
    ctx.save();
    ctx.font = '14px system-ui, sans-serif';
    const pad = 8; const w = ctx.measureText(text).width + pad*2; const h = 26;
    const x = (W - w - 12), y = 12;
    ctx.fillStyle = 'rgba(17,24,39,0.9)';
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    roundRect(ctx, x, y, w, h, 10);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = 'rgba(226,232,240,0.9)';
    ctx.fillText(text, x+pad, y+17);
    ctx.restore();
  }

  function drawPlayerHP(){
    const x = 12, y = 70, w = 220, h = 16;
    ctx.save();
    ctx.fillStyle = 'rgba(17,24,39,0.9)';
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    roundRect(ctx, x-6, y-6, w+12, h+12, 10);
    ctx.fill(); ctx.stroke();

    // base
    ctx.fillStyle = '#7f1d1d';
    roundRect(ctx, x, y, w, h, 8);
    ctx.fill();
    // current
    const ratio = Math.max(0, player.hp / player.maxHp);
    ctx.fillStyle = '#22c55e';
    roundRect(ctx, x, y, w*ratio, h, 8);
    ctx.fill();

    // text
    ctx.fillStyle = 'rgba(226,232,240,0.9)';
    ctx.font = '12px system-ui, sans-serif';
    ctx.fillText(`HP: ${player.hp}/${player.maxHp}`, x+8, y+12);
    ctx.restore();
  }

  function drawLives(){
    const x0 = 12, y0 = 100;
    const gap = 8; const size = 14; // heart size
    ctx.save();
    for (let i=0;i<3;i++){
      const x = x0 + i*(size*2 + gap);
      drawHeart(x, y0, size, i < player.lives ? '#ef4444' : 'rgba(255,255,255,0.15)');
    }
    ctx.restore();
  }

  function drawHeart(x, y, s, color){
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(0, s);
    ctx.bezierCurveTo(-s, 0, -s, -s, 0, -s*0.5);
    ctx.bezierCurveTo(s, -s, s, 0, 0, s);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.stroke();
    ctx.restore();
  }

  function drawLevelBanner(){
    // top center panel with level and damage multiplier
    const dmgMult = damageMultiplier();
    const label = `Nivel ${level}${level===5? ' (Jefe)' : ''}`;
    const sub = `Dificultad x${dmgMult}`;
    ctx.save();
    ctx.font = 'bold 16px system-ui, sans-serif';
    const pad = 8; const w = Math.max(ctx.measureText(label).width, ctx.measureText(sub).width) + pad*2; const h = 42;
    const x = (W - w) / 2; const y = 10;
    ctx.fillStyle = 'rgba(17,24,39,0.9)';
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    roundRect(ctx, x, y, w, h, 10);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#e5e7eb';
    ctx.fillText(label, x+pad, y+18);
    ctx.font = '12px system-ui, sans-serif';
    ctx.fillStyle = 'rgba(226,232,240,0.85)';
    ctx.fillText(sub, x+pad, y+34);

    // Brief big banner when level just started
    if (levelBannerTimer > 0){
      levelBannerTimer -= 1/60; // approximate fade per frame
      ctx.save();
      ctx.globalAlpha = Math.min(1, levelBannerTimer / 1.5);
      ctx.font = 'bold 36px system-ui, sans-serif';
      const msg = label;
      const w2 = ctx.measureText(msg).width;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect((W-w2)/2-20, H*0.42-36, w2+40, 56);
      ctx.fillStyle = '#e5e7eb';
      ctx.fillText(msg, (W-w2)/2, H*0.42);
      ctx.restore();
    }

    ctx.restore();
  }

  function drawGameOver(){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#e5e7eb';
    ctx.font = 'bold 32px system-ui, sans-serif';
    const msg = 'GAME OVER';
    const w1 = ctx.measureText(msg).width;
    ctx.fillText(msg, (W-w1)/2, H/2 - 10);
    ctx.font = '16px system-ui, sans-serif';
    const msg2 = 'Presioná R para reiniciar';
    const w2 = ctx.measureText(msg2).width;
    ctx.fillText(msg2, (W-w2)/2, H/2 + 20);
    ctx.restore();
  }

  function roundRect(ctx,x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function resetGame(){
    projectiles.length = 0;
    enemies.length = 0;
    score = 0;
    gameOver = false;
    player.pos = V(W/2, H/2);
    player.target = V(W/2, H/2);
    player.hasTarget = false;
    player.inventory = [];
    player.hp = player.maxHp;
    player.lives = 3;
    player.iTimer = 0;
    player.lastHitAt = 0;
    cycle = 0;
    startLevel(1);
  }
})();
</script>
</body>
</html>
